'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactStorageHooks = require('react-storage-hooks');
var crypto = require('crypto');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const isClient = typeof window === 'object';

const formatCurrencyString = ({
  value,
  currency,
  language = isClient ? navigator.language : 'en-US'
}) => {
  value = parseInt(value);
  const numberFormat = new Intl.NumberFormat(language, {
    style: 'currency',
    currency,
    currencyDisplay: 'symbol'
  });
  const parts = numberFormat.formatToParts(value);
  let zeroDecimalCurrency = true;

  for (const part of parts) {
    if (part.type === 'decimal') {
      zeroDecimalCurrency = false;
      break
    }
  }

  value = zeroDecimalCurrency ? value : value / 100;
  return numberFormat.format(value.toFixed(2))
};

function useLocalStorageReducer(key, reducer, initialState) {
  const dummyStorage = {
    getItem() {
      return null
    },
    setItem() {},
    removeItem() {}
  };
  return reactStorageHooks.useStorageReducer(
    isClient ? window.localStorage : dummyStorage,
    key,
    reducer,
    initialState
  )
}

const getCheckoutData = {
  stripe(cart) {
    const lineItems = [];
    for (const sku in cart.cartDetails)
      lineItems.push({ price: sku, quantity: cart.cartDetails[sku].quantity });

    const options = {
      mode: 'payment',
      lineItems,
      successUrl: cart.successUrl,
      cancelUrl: cart.cancelUrl,
      billingAddressCollection: cart.billingAddressCollection
        ? 'required'
        : 'auto',
      submitType: 'auto'
    };

    if (_optionalChain([cart, 'access', _ => _.allowedCountries, 'optionalAccess', _2 => _2.length])) {
      options.shippingAddressCollection = {
        allowedCountries: cart.allowedCountries
      };
    }

    return options
  }
};

function checkoutHandler(cart, checkoutOptions) {
  let serviceProperty = '';
  if (cart.stripe) serviceProperty = 'stripe';

  const needsCheckoutData = cart.mode === 'client-only';

  return async function (parameters) {
    if (!serviceProperty) {
      throw new Error(
        'No compatible API has been defined, your options are: Stripe'
      )
    }

    if (!checkoutOptions.modes.includes(cart.mode)) {
      throw new Error(
        `Invalid checkout mode '${
          cart.mode
        }' was chosen. The valid modes are ${new Intl.ListFormat().format(
          checkoutOptions.modes
        )}.`
      )
    }

    let options = { sessionId: _optionalChain([parameters, 'optionalAccess', _3 => _3.sessionId]) };
    if (needsCheckoutData) options = getCheckoutData.stripe(cart);

    const { error } = await checkoutOptions[serviceProperty](
      await cart[serviceProperty],
      options,
      parameters
    );
    if (error) return error
  }
}

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto__default['default'].randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

const cartInitialState = {
  lastClicked: '',
  shouldDisplayCart: false,
  stripe: null
};
function cartReducer(cart, action) {
  switch (action.type) {
    case 'store-last-clicked':
      return {
        ...cart,
        lastClicked: action.id
      }

    case 'cart-click':
      return {
        ...cart,
        shouldDisplayCart: !cart.shouldDisplayCart
      }

    case 'cart-hover':
      return {
        ...cart,
        shouldDisplayCart: true
      }

    case 'close-cart':
      return {
        ...cart,
        shouldDisplayCart: false
      }

    case 'stripe-changed':
      return {
        ...cart,
        stripe: action.stripe
      }

    default:
      return cart
  }
}

const cartValuesInitialState = {
  cartDetails: {},
  totalPrice: 0,
  cartCount: 0
};

function Entry(
  product,
  quantity,
  currency,
  language,
  price_metadata,
  product_metadata
) {
  const id =
    product.id || product.price_id || product.sku_id || product.sku || v4();

  if (!product.price_data && price_metadata) {
    product.price_data = {
      ...price_metadata
    };
  } else if (product.price_data && price_metadata) {
    product.price_data = {
      ...product.price_data,
      ...price_metadata
    };
  }

  if (!product.product_data && product_metadata) {
    product.product_data = {
      ...product_metadata
    };
  } else if (product.product_data && product_metadata) {
    product.product_data = {
      ...product.product_data,
      ...product_metadata
    };
  }

  return {
    ...product,
    id,
    quantity,
    get value() {
      return this.price * this.quantity
    },
    get formattedValue() {
      return formatCurrencyString({
        value: this.value,
        currency,
        language
      })
    }
  }
}
function cartValuesReducer(state, action) {
  function createEntry(product, count, price_metadata, product_metadata) {
    const entry = Entry(
      product,
      count,
      action.currency,
      action.language,
      price_metadata,
      product_metadata
    );

    return {
      cartDetails: {
        ...state.cartDetails,
        [entry.id]: entry
      },
      totalPrice: state.totalPrice + product.price * count,
      cartCount: state.cartCount + count
    }
  }

  function updateEntry(sku, count, price_metadata, product_metadata) {
    const cartDetails = { ...state.cartDetails };
    const entry = cartDetails[sku];
    if (entry.quantity + count <= 0) return removeEntry(sku)

    if (!entry.price_data && price_metadata) {
      entry.price_data = {
        ...price_metadata
      };
    } else if (entry.price_data && price_metadata) {
      entry.price_data = {
        ...entry.price_data,
        ...price_metadata
      };
    }

    if (!entry.product_data && product_metadata) {
      entry.product_data = {
        ...product_metadata
      };
    } else if (entry.product_data && product_metadata) {
      entry.product_data = {
        ...entry.product_data,
        ...product_metadata
      };
    }

    cartDetails[sku] = Entry(
      entry,
      entry.quantity + count,
      action.currency,
      action.language,
      price_metadata,
      product_metadata
    );

    return {
      cartDetails,
      totalPrice: state.totalPrice + entry.price * count,
      cartCount: state.cartCount + count
    }
  }

  function removeEntry(sku) {
    const cartDetails = { ...state.cartDetails };
    const totalPrice = state.totalPrice - cartDetails[sku].value;
    const cartCount = state.cartCount - cartDetails[sku].quantity;
    delete cartDetails[sku];

    return { cartDetails, totalPrice, cartCount }
  }

  function updateQuantity(sku, quantity) {
    const entry = state.cartDetails[sku];
    return updateEntry(sku, quantity - entry.quantity)
  }

  switch (action.type) {
    case 'add-item-to-cart':
      if (action.count <= 0) break
      if (action.product.id in state.cartDetails)
        return updateEntry(
          action.product.id,
          action.count,
          action.price_metadata,
          action.product_metadata
        )
      return createEntry(
        action.product,
        action.count,
        action.price_metadata,
        action.product_metadata
      )

    case 'increment-item':
      if (action.count <= 0) break
      if (action.id in state.cartDetails)
        return updateEntry(action.id, action.count)
      break

    case 'decrement-item':
      if (action.count <= 0) break
      if (action.id in state.cartDetails)
        return updateEntry(action.id, -action.count)
      break

    case 'set-item-quantity':
      if (action.count < 0) break
      if (action.id in state.cartDetails)
        return updateQuantity(action.id, action.quantity)
      break

    case 'remove-item-from-cart':
      if (action.id in state.cartDetails) return removeEntry(action.id)
      break

    case 'clear-cart':
      return cartValuesInitialState

    case 'load-cart':
      if (!action.shouldMerge) state = { ...cartValuesInitialState };

      for (const sku in action.cartDetails) {
        const entry = action.cartDetails[sku];
        if (action.filter && !action.filter(entry)) continue

        state = createEntry(entry, entry.quantity);
      }
      return state

    default:
      return state
  }

  console.warn('Invalid action arguments', action);
  return state
}

const _jsxFileName = "/Users/nickdejesus/Code/hooks/use-shopping-cart/use-shopping-cart/src/index.js";
const CartContext = React.createContext([
  {
    lastClicked: '',
    shouldDisplayCart: false,
    ...cartValuesInitialState
  },
  () => {}
]);

function CartProvider({
  children,
  mode,
  stripe,
  successUrl,
  cancelUrl,
  currency,
  language = isClient ? navigator.language : 'en-US',
  billingAddressCollection = false,
  allowedCountries = null
}) {
  const [cart, cartDispatch] = React.useReducer(cartReducer, cartInitialState);

  React.useEffect(() => {
    cartDispatch({ type: 'stripe-changed', stripe });
  }, [stripe]);

  const [cartValues, cartValuesDispatch] = useLocalStorageReducer(
    'cart-values',
    cartValuesReducer,
    cartValuesInitialState
  );

  // combine dispatches and
  // memoize context value to avoid causing re-renders
  const contextValue = React.useMemo(
    () => [
      {
        ...cart,
        ...cartValues,
        mode,
        successUrl,
        cancelUrl,
        currency,
        language,
        billingAddressCollection,
        allowedCountries
      },
      (action) => {
        cartDispatch(action);
        cartValuesDispatch({ ...action, currency, language });
      }
    ],
    [
      cart,
      cartDispatch,
      cartValues,
      cartValuesDispatch,
      mode,
      successUrl,
      cancelUrl,
      currency,
      language,
      billingAddressCollection,
      allowedCountries
    ]
  );

  return (
    React__default['default'].createElement(CartContext.Provider, { value: contextValue, __self: this, __source: {fileName: _jsxFileName, lineNumber: 93}}, children)
  )
}

const useShoppingCart = () => {
  const [cart, dispatch] = React.useContext(CartContext);

  const {
    lastClicked,
    shouldDisplayCart,
    cartCount,
    cartDetails,
    totalPrice,
    currency,
    language
  } = cart;

  const addItem = (product, count = 1, price_metadata, product_metadata) => {
    dispatch({
      type: 'add-item-to-cart',
      product,
      count,
      price_metadata,
      product_metadata
    });
  };

  const removeItem = (id) => dispatch({ type: 'remove-item-from-cart', id });
  const setItemQuantity = (id, quantity) =>
    dispatch({ type: 'set-item-quantity', id, quantity });
  const incrementItem = (id, count = 1) =>
    dispatch({ type: 'increment-item', id, count });
  const decrementItem = (id, count = 1) =>
    dispatch({ type: 'decrement-item', id, count });
  const clearCart = () => dispatch({ type: 'clear-cart' });

  const storeLastClicked = (id) => dispatch({ type: 'store-last-clicked', id });
  const handleCartClick = () => dispatch({ type: 'cart-click' });
  const handleCartHover = () => dispatch({ type: 'cart-hover' });
  const handleCloseCart = () => dispatch({ type: 'close-cart' });

  const loadCart = (cartDetails, shouldMerge = true) =>
    dispatch({ type: 'load-cart', cartDetails, shouldMerge });

  const redirectToCheckout = checkoutHandler(cart, {
    modes: ['client-only', 'checkout-session'],
    stripe(stripe, options) {
      return stripe.redirectToCheckout(options)
    }
  });

  const checkoutSingleItem = checkoutHandler(cart, {
    modes: ['client-only'],
    stripe(stripe, options, { sku, quantity = 1 }) {
      options.lineItems = [{ price: sku, quantity }];
      return stripe.redirectToCheckout(options)
    }
  });

  const shoppingCart = {
    cartDetails,
    cartCount,
    totalPrice,
    get formattedTotalPrice() {
      return formatCurrencyString({
        value: totalPrice,
        currency,
        language
      })
    },

    addItem,
    removeItem,
    setItemQuantity,
    incrementItem,
    decrementItem,
    clearCart,
    lastClicked,
    storeLastClicked,
    shouldDisplayCart,
    handleCartClick,
    handleCartHover,
    handleCloseCart,
    redirectToCheckout,
    checkoutSingleItem,
    loadCart
  };
  React.useDebugValue(shoppingCart);
  return shoppingCart
};

function DebugCart(props) {
  const cart = useShoppingCart();
  const cartPropertyRows = Object.entries(cart)
    .filter(([, value]) => typeof value !== 'function')
    .map(([key, value]) => (
      React__default['default'].createElement('tr', { key: key, __self: this, __source: {fileName: _jsxFileName, lineNumber: 189}}
        , React__default['default'].createElement('td', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 190}}, key)
        , React__default['default'].createElement('td', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 191}}
          , typeof value === 'object' ? (
            React__default['default'].createElement('button', { onClick: () => console.log(value), __self: this, __source: {fileName: _jsxFileName, lineNumber: 193}}, "Log value" )
          ) : (
            JSON.stringify(value)
          )
        )
      )
    ));

  return (
    React__default['default'].createElement('table', {
      style: {
        position: 'fixed',
        top: 50,
        right: 50,
        backgroundColor: '#eee',
        textAlign: 'left',
        maxWidth: 500,
        padding: 20,
        borderSpacing: '25px 5px'
      },
      ...props, __self: this, __source: {fileName: _jsxFileName, lineNumber: 202}}
    
      , React__default['default'].createElement('thead', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 215}}
        , React__default['default'].createElement('tr', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 216}}
          , React__default['default'].createElement('th', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 217}}, "Key")
          , React__default['default'].createElement('th', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 218}}, "Value")
        )
      )
      , React__default['default'].createElement('tbody', {__self: this, __source: {fileName: _jsxFileName, lineNumber: 221}}, cartPropertyRows)
    )
  )
}

exports.CartContext = CartContext;
exports.CartProvider = CartProvider;
exports.DebugCart = DebugCart;
exports.formatCurrencyString = formatCurrencyString;
exports.isClient = isClient;
exports.useShoppingCart = useShoppingCart;
//# sourceMappingURL=index.js.map
